<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gravador de Entrevista (com intro/outro e export MP3)</title>
  <style>
    body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:24px;background:#f6f8fb;color:#0f172a}
    .card{background:#fff;border-radius:12px;padding:20px;max-width:820px;margin:0 auto;box-shadow:0 6px 18px rgba(15,23,42,0.06)}
    h1{font-size:20px;margin:0 0 12px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
    button{padding:10px 14px;border-radius:8px;border:0;background:#0ea5a4;color:#fff;cursor:pointer}
    button.secondary{background:#64748b}
    button.danger{background:#ef4444}
    audio{width:100%;margin-top:12px}
    .status{margin-top:8px;color:#475569}
    .hint{font-size:13px;color:#64748b;margin-top:8px}
    .row{display:flex;gap:8px;align-items:center}
  </style>
  <!-- LameJS: encoder MP3 em JS (CDN) -->
  <script src="https://unpkg.com/lamejs@1.2.0/lame.min.js"></script>
</head>
<body>
  <div class="card">
    <h1>Gravador de Entrevista</h1>
    <div class="controls">
      <button id="startBtn">Iniciar gravação</button>
      <button id="pauseBtn" class="secondary" disabled>Pausar</button>
      <button id="resumeBtn" class="secondary" disabled>Retomar</button>
      <button id="stopBtn" class="danger" disabled>Concluir gravação</button>
      <button id="exportBtn" class="secondary" disabled>Adicionar intro/fim e gerar MP3</button>
      <a id="downloadLink" style="display:none" download="entrevista.mp3"><button>Download MP3</button></a>
    </div>

    <div class="row">
      <div class="status">Status: <span id="statusText">Pronto</span></div>
      <div style="margin-left:auto" class="hint">Coloque <strong>inicio.mp3</strong> e <strong>fim.mp3</strong> na mesma pasta deste arquivo HTML.</div>
    </div>

    <audio id="preview" controls></audio>

    <div class="hint">Observações: O navegador solicitará permissão para usar o microfone. O arquivo final será codificado em MP3 no próprio navegador (usa lamejs).</div>
  </div>

<script>
(async function(){
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const stopBtn = document.getElementById('stopBtn');
  const exportBtn = document.getElementById('exportBtn');
  const downloadLink = document.getElementById('downloadLink');
  const preview = document.getElementById('preview');
  const statusText = document.getElementById('statusText');

  let mediaRecorder = null;
  let chunks = [];
  let recordingBlob = null;
  let streamRef = null;

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function setStatus(s){ statusText.textContent = s; }

  startBtn.addEventListener('click', async ()=>{
    try{
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Error('Navegador não suporta getUserMedia');
      setStatus('Pedindo permissão...');
      const s = await navigator.mediaDevices.getUserMedia({ audio: true });
      streamRef = s;
      mediaRecorder = new MediaRecorder(s);
      chunks = [];

      mediaRecorder.ondataavailable = e => { if(e.data && e.data.size) chunks.push(e.data); };
      mediaRecorder.onstop = ()=>{
        recordingBlob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' });
        preview.src = URL.createObjectURL(recordingBlob);
        exportBtn.disabled = false;
        setStatus('Gravação concluída - pronta para exportar.');
        // stop tracks to release mic
        if(streamRef){ streamRef.getTracks().forEach(t=>t.stop()); streamRef=null; }
      };

      mediaRecorder.start();
      setStatus('Gravando...');
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      stopBtn.disabled = false;
    }catch(err){
      console.error(err);
      setStatus('Erro ao acessar microfone: '+err.message);
    }
  });

  pauseBtn.addEventListener('click', ()=>{
    if(mediaRecorder && mediaRecorder.state === 'recording'){
      mediaRecorder.pause();
      setStatus('Gravação pausada');
      pauseBtn.disabled = true;
      resumeBtn.disabled = false;
    }
  });

  resumeBtn.addEventListener('click', ()=>{
    if(mediaRecorder && mediaRecorder.state === 'paused'){
      mediaRecorder.resume();
      setStatus('Gravando...');
      pauseBtn.disabled = false;
      resumeBtn.disabled = true;
    }
  });

  stopBtn.addEventListener('click', ()=>{
    if(mediaRecorder && (mediaRecorder.state === 'recording' || mediaRecorder.state === 'paused')){
      mediaRecorder.stop();
      setStatus('Finalizando...');
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      resumeBtn.disabled = true;
      stopBtn.disabled = true;
    }
  });

  // util: decode audio file (from relative path) to AudioBuffer
  async function fetchAndDecode(path){
    try{
      const resp = await fetch(path);
      if(!resp.ok) throw new Error('Arquivo não encontrado: '+path);
      const ab = await resp.arrayBuffer();
      const buf = await audioCtx.decodeAudioData(ab.slice(0));
      return buf;
    }catch(e){
      throw e;
    }
  }

  // mix multi-channel AudioBuffer to mono Float32Array
  function toMonoFloat32(buffer){
    const ch = buffer.numberOfChannels;
    const len = buffer.length;
    const result = new Float32Array(len);
    for(let c=0;c<ch;c++){
      const data = buffer.getChannelData(c);
      for(let i=0;i<len;i++) result[i] = (result[i] || 0) + data[i] / ch;
    }
    return result;
  }

  function concatFloat32(arrays){
    let totalLen = arrays.reduce((s,a)=>s+a.length,0);
    const out = new Float32Array(totalLen);
    let offset = 0;
    for(const a of arrays){ out.set(a, offset); offset += a.length; }
    return out;
  }

  function floatTo16BitPCM(float32){
    const l = float32.length;
    const out = new Int16Array(l);
    for(let i=0;i<l;i++){
      let s = Math.max(-1, Math.min(1, float32[i]));
      out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    return out;
  }

  exportBtn.addEventListener('click', async ()=>{
    if(!recordingBlob){ setStatus('Nenhuma gravação encontrada.'); return; }
    exportBtn.disabled = true;
    setStatus('Preparando arquivos (intro, gravação, fim)...');

    try{
      const [introBuf, outroBuf, recAB] = await Promise.all([
        fetchAndDecode('inicio.mp3').catch(()=>null),
        fetchAndDecode('fim.mp3').catch(()=>null),
        recordingBlob.arrayBuffer()
      ]);

      const recBuf = await audioCtx.decodeAudioData(recAB.slice(0));

      const segments = [];
      if(introBuf) segments.push(toMonoFloat32(introBuf));
      segments.push(toMonoFloat32(recBuf));
      if(outroBuf) segments.push(toMonoFloat32(outroBuf));

      const combined = concatFloat32(segments);
      const sampleRate = recBuf.sampleRate || audioCtx.sampleRate || 44100;

      setStatus('Codificando para MP3 (isso pode levar alguns segundos)...');

      // encode with lamejs
      const mp3Encoder = new lamejs.Mp3Encoder(1, sampleRate, 128);
      const samples16 = floatTo16BitPCM(combined);

      const mp3Data = [];
      const maxSamples = 1152 * 10; // chunk size
      for(let i=0;i<samples16.length;i+=maxSamples){
        const chunk = samples16.subarray(i, i+maxSamples);
        const mp3buf = mp3Encoder.encodeBuffer(chunk);
        if(mp3buf.length>0) mp3Data.push(new Int8Array(mp3buf));
      }
      const mp3buf = mp3Encoder.flush();
      if(mp3buf.length>0) mp3Data.push(new Int8Array(mp3buf));

      const mp3Blob = new Blob(mp3Data, { type: 'audio/mpeg' });
      const url = URL.createObjectURL(mp3Blob);
      downloadLink.href = url;
      downloadLink.style.display = 'inline-block';
      downloadLink.download = 'entrevista.mp3';
      preview.src = url;
      setStatus('MP3 pronto. Clique em "Download MP3" para baixar.');
    }catch(err){
      console.error(err);
      setStatus('Erro ao gerar MP3: '+err.message);
      exportBtn.disabled = false;
    }
  });

})();
</script>
</body>
</html>
